#Conctions nécessaires aux fonctionnements des autres scripts Python

# -*- coding: utf-8 -*-
"""
Created on Thu Apr 20 09:06:48 2017

@author: nlelievre
"""
import numpy as np
import scipy as sp
from scipy.stats import norm

""" Fonction de performance fonction de la dimension"""
def G(X):
#    out=X[:,0]-3/2*X[:,1]*(X[:,2]**3)*(((X[:,2]**3-X[:,3]**3))**(-1));
#    n = X.shape[1]
#    out =  (n + 3*0.2*np.sqrt(n)) - np.sum(X,1)# - X[:,0]*X[:,-1] + 0.4*X[:,1]*X[:,-2] + X[:,4]*X[:,7]*X[:,10]*X[:,5]
#    return out
#    """ Fonction de performance académique 26-51-101"""  
#    out = X[:,0] - 3/2 * X[:,1] * (X[:,2])**3 * ((X[:,2])**3 - (X[:,3])**3)**(-1)
#    return out
#""" Fonction de performance académique 26-51-101"""
#def G(X):
#    n = X.shape[1]
#    out =  (n + 3*0.2*np.sqrt(n)) -np.sum(X,1)
#    return out
#
#""" Fonction de performance Oakley & O'Hagan"""
#def G(X):
#    m = X.shape[0]
#    M = np.array([[-2.2482886e-002, -1.8501666e-001,  1.3418263e-001,  3.6867264e-001,  1.7172785e-001,  1.3651143e-001, -4.4034404e-001, -8.1422854e-002,  7.1321025e-001, -4.4361072e-001,  5.0383394e-001, -2.4101458e-002, -4.5939684e-002,  2.1666181e-001,  5.5887417e-002],
#                      [ 2.5659630e-001,  5.3792287e-002,  2.5800381e-001,  2.3795905e-001, -5.9125756e-001, -8.1627077e-002, -2.8749073e-001,  4.1581639e-001,  4.9752241e-001,  8.3893165e-002, -1.1056683e-001,  3.3222351e-002, -1.3979497e-001, -3.1020556e-002, -2.2318721e-001],
#                      [-5.5999811e-002,  1.9542252e-001,  9.5529005e-002, -2.8626530e-001, -1.4441303e-001,  2.2369356e-001,  1.4527412e-001,  2.8998481e-001,  2.3105010e-001, -3.1929879e-001, -2.9039128e-001, -2.0956898e-001,  4.3139047e-001,  2.4429152e-002,  4.4904409e-002],
#                      [ 6.6448103e-001,  4.3069872e-001,  2.9924645e-001, -1.6202441e-001, -3.1479544e-001, -3.9026802e-001,  1.7679822e-001,  5.7952663e-002,  1.7230342e-001,  1.3466011e-001, -3.5275240e-001,  2.5146896e-001, -1.8810529e-002,  3.6482392e-001, -3.2504618e-001],
#                      [-1.2127800e-001,  1.2463327e-001,  1.0656519e-001,  4.6562296e-002, -2.1678617e-001,  1.9492172e-001, -6.5521126e-002,  2.4404669e-002, -9.6828860e-002,  1.9366196e-001,  3.3354757e-001,  3.1295994e-001, -8.3615456e-002, -2.5342082e-001,  3.7325717e-001],
#                      [-2.8376230e-001, -3.2820154e-001, -1.0496068e-001, -2.2073452e-001, -1.3708154e-001, -1.4426375e-001, -1.1503319e-001,  2.2424151e-001, -3.0395022e-002, -5.1505615e-001,  1.7254978e-002,  3.8957118e-002,  3.6069184e-001,  3.0902452e-001,  5.0030193e-002],
#                      [-7.7875893e-002,  3.7456560e-003,  8.8685604e-001, -2.6590028e-001, -7.9325357e-002, -4.2734919e-002, -1.8653782e-001, -3.5604718e-001, -1.7497421e-001,  8.8699956e-002,  4.0025886e-001, -5.5979693e-002,  1.3724479e-001,  2.1485613e-001, -1.1265799e-002],
#                      [-9.2294730e-002,  5.9209563e-001,  3.1338285e-002, -3.3080861e-002, -2.4308858e-001, -9.9798547e-002,  3.4460195e-002,  9.5119813e-002, -3.3801620e-001,  6.3860024e-003, -6.1207299e-001,  8.1325416e-002,  8.8683114e-001,  1.4254905e-001,  1.4776204e-001],
#                      [-1.3189434e-001,  5.2878496e-001,  1.2652391e-001,  4.5113625e-002,  5.8373514e-001,  3.7291503e-001,  1.1395325e-001, -2.9479222e-001, -5.7014085e-001,  4.6291592e-001, -9.4050179e-002,  1.3959097e-001, -3.8607402e-001, -4.4897060e-001, -1.4602419e-001],
#                      [ 5.8107658e-002, -3.2289338e-001,  9.3139162e-002,  7.2427234e-002, -5.6919401e-001,  5.2554237e-001,  2.3656926e-001, -1.1782016e-002,  7.1820601e-002,  7.8277291e-002, -1.3355752e-001,  2.2722721e-001,  1.4369455e-001, -4.5198935e-001, -5.5574794e-001],
#                      [ 6.6145875e-001,  3.4633299e-001,  1.4098019e-001,  5.1882591e-001, -2.8019898e-001, -1.6032260e-001, -6.8413337e-002, -2.0428242e-001,  6.9672173e-002,  2.3112577e-001, -4.4368579e-002, -1.6455425e-001,  2.1620977e-001,  4.2702105e-003, -8.7399014e-002],
#                      [ 3.1599556e-001, -2.7551859e-002,  1.3434254e-001,  1.3497371e-001,  5.4005680e-002, -1.7374789e-001,  1.7525393e-001,  6.0258929e-002, -1.7914162e-001, -3.1056619e-001, -2.5358691e-001,  2.5847535e-002, -4.3006001e-001, -6.2266361e-001, -3.3996882e-002],
#                      [-2.9038151e-001,  3.4101270e-002,  3.4903413e-002, -1.2121764e-001,  2.6030714e-002, -3.3546274e-001, -4.1424111e-001,  5.3248380e-002, -2.7099455e-001, -2.6251302e-002,  4.1024137e-001,  2.6636349e-001,  1.5582891e-001, -1.8666254e-001,  1.9895831e-002],
#                      [-2.4388652e-001, -4.4098852e-001,  1.2618825e-002,  2.4945112e-001,  7.1101888e-002,  2.4623792e-001,  1.7484502e-001,  8.5286769e-003,  2.5147070e-001, -1.4659862e-001, -8.4625150e-002,  3.6931333e-001, -2.9955293e-001,  1.1044360e-001, -7.5690139e-001],
#                      [ 4.1494323e-002, -2.5980564e-001,  4.6402128e-001, -3.6112127e-001, -9.4980789e-001, -1.6504063e-001,  3.0943325e-003,  5.2792942e-002,  2.2523648e-001,  3.8390366e-001,  4.5562427e-001, -1.8631744e-001,  8.2333995e-003,  1.6670803e-001,  1.6045688e-001]])
#    a1 = np.array([[0.0118],[0.0456],[0.2297],[0.0393],[0.1177],[0.3865],[0.3897],[0.6061],[0.6159],[0.4005],[1.0741],[1.1474],[0.7880],[1.1242],[1.1982]])
#    a2 = np.array([[0.4341],[0.0887],[0.0512],[0.3233],[0.1489],[1.0360],[0.9892],[0.9672],[0.8977],[0.8083],[1.8426],[2.4712],[2.3946],[2.0045],[2.2621]])
#    a3 = np.array([[0.1044],[0.2057],[0.0774],[0.2730],[0.1253],[0.7526],[0.8570],[1.0331],[0.8388],[0.7970],[2.2145],[2.0382],[2.4004],[2.0541],[1.9845]])
#    out = np.zeros((m,1))
#    for i in np.arange(m):
#        out[i,0] =  np.dot(a1.transpose(),X[i,:].transpose()) + np.dot(a2.transpose(),np.sin(X[i,:].transpose())) + np.dot(a3.transpose(),np.cos(X[i,:].transpose())) + np.dot(np.dot(X[i,:],M),X[i,:].transpose())
#    return out
    out = X[:,0]
    return out


def tisoinv(U, Loi, Moy, Stdev):
    X = np.zeros(U.shape)
    nva = np.size(Loi)
    for i in np.arange(nva):
        if Loi[i] == 0:
            """Loi déterministe X = moyenne"""       
            X[:,i] = Moy[i]
        elif Loi[i] == 1:
            """Loi normale"""
            X[:,i] = Stdev[i] * U[:,i] + Moy[i]     
        elif Loi[i] == 2:
            """Loi log-normale"""
            mulog = np.log((Moy[i] ** 2)/(np.sqrt(Moy[i] ** 2 + Stdev[i] ** 2)))
            siglog = np.sqrt(np.log(1 + Stdev[i] ** 2 / Moy[i] ** 2))
            X[:,i] = np.exp(siglog * U[:,i] + mulog)              
        elif Loi[i] == 3:
            """Loi uniforme"""
            a = Moy[i] - np.sqrt(3) * Stdev[i]
            b = Moy[i] + np.sqrt(3) * Stdev[i]
            X[:,i] = (b-a) * norm.cdf(U[:,i]) + a                     
        elif Loi[i] == 4:
            """Loi de Weibull"""
            ratio = 1.0 + (Stdev[i] / Moy[i]) ** 2.
            betaMin = 1
            betaMax = 1
            step = 0.5
            epsilon = 1.e-12

            if ratio > 2 :
                betaMin = betaMin - step
                step = step * 0.5
                t = np.exp(np.log(sp.special.gamma(1.0 + 2.0 / betaMin)) - 2.0 * np.log(sp.special.gamma(1.0 + 1.0 / betaMin)))
                while t < ratio:
                    betaMin = betaMin - step
                    step = step * 0.5
                    t = np.exp(np.log(sp.special.gamma(1.0 + 2.0 / betaMin)) - 2.0 * np.log(sp.special.gamma(1.0 + 1.0 / betaMin)))
                betaMax = betaMin + 2.0 * step

            else:
                betaMax = betaMax + step
                step = step * 2.0
                t = np.exp(np.log(sp.special.gamma(1.0 + 2.0 / betaMax)) - 2.0 * np.log(sp.special.gamma(1.0 + 1.0 / betaMax)))
                while t >= ratio:
                    betaMax = betaMax + step
                    step = step * 2.0
                    t = np.exp(np.log(sp.special.gamma(1.0 + 2.0 / betaMax)) - 2.0 * np.log(sp.special.gamma(1.0 + 1.0 / betaMax)))
                betaMin = betaMax - 0.5 * step

            while 1:
                kW = 0.5 * (betaMin + betaMax)
                if (betaMax - betaMin <= epsilon * (1.0 + abs(betaMax + betaMin))):
                    lambdaW = Moy[i] / sp.special.gamma(1.0 + 1.0 / kW)
                    break
                t = np.exp(np.log(sp.special.gamma(1.0 + 2.0 / kW)) - 2.0 * np.log(sp.special.gamma(1.0 + 1.0 / kW)))
                if (t < ratio):
                    betaMax = kW
                else:
                    betaMin = kW

            X[:,i] = lambdaW * (-1.0 * np.log(1.0 - norm.cdf(U[:,i]))) ** (1./kW)            
            
            
        elif Loi[i] == 5:
            """Loi de Gumbel"""
            cstgamma = 0.5772;
            Beta = np.sqrt(6)*Stdev[i]/sp.pi;
            Mu = Moy[i] - Beta*cstgamma;
            X[:,i] = Mu - Beta*np.log(-np.log(norm.cdf(U[:,i])));
    return X

def Perf(U, Seuil, Loi, Moy, Stdev):
    X = tisoinv(U,Loi,Moy,Stdev)
    fonctionG = G(X)
    P = fonctionG-Seuil
    return P
